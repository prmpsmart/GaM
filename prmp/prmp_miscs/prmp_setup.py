
from os import mkdir, path, listdir, sys, chdir, pathsep, system, get_exec_path

inno_script_example = '''
    ; Script generated by the PRMP Smart SETUP WIZARD.
    ; SEE THE DOCUMENTATION FOR DETAILS ON CREATING PRMP Smart SETUP SCRIPT FILES!

    #define MyAppName "TranxFer"
    #define MyAppVersion "1.5"
    #define MyAppPublisher "PRMPSmart Inc."
    #define MyAppURL "http://www.tranxFer.com/"
    #define MyAppExeName "TranxFer.exe"

    [Setup]
    ; NOTE: The value of AppId uniquely identifies this application. Do not use the same AppId value in installers for other applications.
    ; (To generate a new GUID, click Tools | Generate GUID inside the IDE.)
    AppId={{C280E116-9281-4691-B2FE-E53773049917}
    AppName={#MyAppName}
    AppVersion={#MyAppVersion}
    ;AppVerName={#MyAppName} {#MyAppVersion}
    AppPublisher={#MyAppPublisher}
    AppPublisherURL={#MyAppURL}
    AppSupportURL={#MyAppURL}
    AppUpdatesURL={#MyAppURL}
    DefaultDirName={autopf}\{#MyAppName}
    DefaultGroupName={#MyAppName}
    AllowNoIcons=yes
    ; The [Icons] "quicklaunchicon" entry uses {userappdata} but its [Tasks] entry has a proper IsAdminInstallMode Check.
    UsedUserAreasWarning=no
    ; Remove the following line to run in administrative install mode (install for all users.)
    PrivilegesRequired=lowest
    PrivilegesRequiredOverridesAllowed=dialog
    OutputDir={output directory here}
    OutputBaseFilename=TranxFer-setup
    Password=mimi
    Compression=lzma
    SolidCompression=yes
    WizardStyle=modern

    [Languages]
    Name: "english"; MessagesFile: "compiler:Default.isl"

    [Tasks]
    Name: "desktopicon"; Description: "{cm:CreateDesktopIcon}"; GroupDescription: "{cm:AdditionalIcons}"; Flags: unchecked
    Name: "quicklaunchicon"; Description: "{cm:CreateQuickLaunchIcon}"; GroupDescription: "{cm:AdditionalIcons}"; Flags: unchecked; OnlyBelowVersion: 6.1; Check: not IsAdminInstallMode

    [Files]
    Source: {put the main exe here};
    DestDir: "{app}"; Flags: ignoreversion
    Source: "{put the path to folder needed here} \*"; DestDir: "{app}"; Flags: ignoreversion recursesubdirs createallsubdirs
    ; NOTE: Don't use "Flags: ignoreversion" on any shared system files

    [Icons]
    Name: "{group}\{#MyAppName}"; Filename: "{app}\{#MyAppExeName}"
    Name: "{group}\{cm:ProgramOnTheWeb,{#MyAppName}}"; Filename: "{#MyAppURL}"
    Name: "{group}\{cm:UninstallProgram,{#MyAppName}}"; Filename: "{uninstallexe}"
    Name: "{autodesktop}\{#MyAppName}"; Filename: "{app}\{#MyAppExeName}"; Tasks: desktopicon
    Name: "{userappdata}\Microsoft\Internet Explorer\Quick Launch\{#MyAppName}"; Filename: "{app}\{#MyAppExeName}"; Tasks: quicklaunchicon

    [Run]
    Filename: "{app}\{#MyAppExeName}"; Description: "{cm:LaunchProgram,{#StringChange(MyAppName, '&', '&&')}}"; Flags: nowait postinstall skipifsilent

'''

classifiers = [
    'Development Status :: 1 - Beta',
    'Environment :: Console',
    'Intended Audience :: Developers',
    'License :: OSI Approved :: Python Software Foundation License',
    'Operating System :: Microsoft :: Windows',
    'Programming Language :: Python',
    'Programming Language :: C/C++',
    'Topic :: Software Development :: Bug Tracking',
]
platforms = ['Windows']
keywords = []
license_ = ''

class Holder: pass


class PRMP_Setup:

    def __init__(self, type_='NaN', *args, **kwargs):
        self.type = type_
        if hasattr(self, self.type): getattr(self, self.type)(*args, **kwargs)
        else: raise ValueError(f'{self.type} is not a valid build type!')

    def build(self):
        func = f'_{self.type}'
        getattr(self, func)()

    def get_scripts(self, folder):
        files = []
        if path.isdir(folder):
            for fi in listdir(folder):
                p = path.join(folder, fi)
                if path.isfile(p): files.append(p)
            return files, f'/{folder}'
        else: return [folder], ''

    def build_ext(self, folder='', scripts=[], description='', meta_datas={}, classifiers=classifiers, platforms=platforms, keywords=[], license=''):
        self.holder = Holder()
        pac = folder[:-3] if folder.endswith('.py') else folder

        self.holder.meta_datas = meta_datas or dict(
            name=pac,
            version='1.0',
            author='PRMPSmart',
            author_email='prmpsmart@gmail.com',
            maintainer='PRMPSmart',
            maintainer_email='prmpsmart@gmail.com',
            url=f'github.com/prmpsmart/{pac}',
            description=description or f'an extension module for {folder}',
            long_description='an example to test the creation of python extension modules et all.',
            download_url=f'github.com/prmpsmart/{pac}.git',
            classifiers=classifiers,
            platforms=platforms,
            keywords=keywords,
            license=license_,
        )
        self.holder.scripts, self.holder.dest = scripts or self.get_scripts(folder)

    def _build_ext(self):
        from distutils.core import setup
        from Cython.Build import cythonize
        for d in ['c', 'pyd']:
            try: mkdir(d)
            except: pass
        ext_modules = cythonize(self.holder.scripts, language_level=3, build_dir='c')
        sys.argv.extend(['build_ext', f'-bpyd{self.holder.dest}'])
        setup(ext_modules=ext_modules, **self.holder.meta_datas)

    def pyinstaller(self, console=True, extra_commands=[], extensions_modules=[], log_level='info', datas={}, binaries={}, name='', onefile=False, icon='', clean=False, noconfirm=False):
        '''
        :param console: a boolean whether to enable consoled executable or not
        :param extra_commands: commands to pass to PyInstaller
        '''

        log_level = log_level.upper()
        log_levels = ["TRACE", "DEBUG", "INFO", "WARN", "ERROR", "CRITICAL"]
        assert log_level in log_levels, f'{log_level} not in {log_levels}.'

        self.holder = Holder()

        self.holder.name = f'-n {name}'

        self.holder.datas = ' '.join([f'--add-data {pathsep.join(data, datas[data])}' for data in datas]) if datas else ''
        self.holder.binaries = ' '.join([f'--add-binary {pathsep.join(binary, binaries[binary])}' for binary in binaries]) if binaries else ''

        self.holder.console = '-c' if console else '-w'
        self.holder.onefile = '-F' if onefile else '-D'
        self.holder.icon = '-i {icon}' if icon else ''

        self.holder.extra_commands = extra_commands
        self.holder.clean = '--clean' if clean else ''
        self.holder.noconfirm = '--noconfirm' if clean else ''
        self.holder.log_level = f'--log-level {log_level}'

        self.holder.run_parameter = [self.holder.name, self.holder.datas, self.holder.binaries, self.holder.console, self.holder.onefile, self.holder.icon, *self.holder.extra_commands, self.holder.clean, self.holder.noconfirm, self.holder.log_level]

    def _pyinstaller(self):
        import PyInstaller.__main__
        PyInstaller.__main__.run(self.holder.run_parameter)

    def inno_setup(self, script, old_ver='', new_ver='', gen_script=False, gui=False, customize=False, author='PRMP Smart'):
        self.holder = Holder()
        self.holder.script = script
        self.holder.new_ver = new_ver
        self.holder.old_ver = old_ver
        self.holder.author = author
        self.holder.gui = gui
        self.holder.customize = customize

        self.holder.script = script
        self.holder.gen_script = f'compil32 /wizard "{author} SETUP WIZARD" "{script}"' if gen_script else False


        program = 'iscc' if not gui else 'compil32 /cc'
        self.holder.program = f'{program} {script}'

    def customize_script(self, script, old_ver='', new_ver='', author=''):
        with open(script) as old: text = old.read()
        text = text.replace("INNO", author)
        if old_ver and new_ver: text = text.replace(old_ver, new_ver)
        with open(script, 'w') as new: new.write(text)

    def _inno_setup(self):
        inno_installed = "Inno Setup".upper() in ''.join(get_exec_path()).upper()
        if not inno_installed: raise ValueError('Inno Setup Compiler is not installed. You can get it on https://jrsoftware.org')

        if self.holder.gen_script: system(self.holder.gen_script)
        if self.holder.customize: self.customize_script(self.holder.script, old_var=self.holder.old_ver, new_var=self.holder.new_ver, author=self.holder.author)
        system(self.holder.program)



f = PRMP_Setup('inno_setup', 'test.iss', gen_script=1)
f._inno_setup()



